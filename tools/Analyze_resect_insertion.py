#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#Author: Mengzhu
#Date:2019.9.9

"""Analyze_perfect_insertion

    This is a pipeline to analyze PEM-seq data or data similar, help you analyze repair outcome of your DNA library.

    Copyright (C) 2019  Mengzhu Liu

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
    USA

Author: Mengzhu LIU
Contact: liu.mengzhu128@gmail.com/liumz@pku.edu.cn

Usage:
    Analyze_perfect_insertion <sequence> <cutsite> <tab_file> <strand>

Options:
<sequence>              must be an x nt sequence, x must be even number, 5'->3', and cutsite at x/2|x/2+1
<cutsite>               3' end of cutsite on positive strand.
<tab_file>              a tab file generated by PEM-SEQ to analyze insertions.
<strand>                strand of your red primer.
-h --help               Show this screen.
-v --version            Show version.

This script .

Author: Mengzhu LIU
Last Update:2019.9.9

"""
import os
import pysam
import re
from time import time
from docopt import docopt
import pandas as pd
from Bio import SearchIO
from Bio.Seq import Seq

def one_insertion(sequence=None,cutsite=None,tab_file=None,strand=None):
    
    data = pd.read_csv(tab_file,sep = '\t',index_col=False,low_memory=False)
    
    one_insertion = open("one_insertion.txt","w")    
    one_insertion.write("Sequence"+"\t"+\
                        "Count"+"\n")
    
    x=len(sequence)
    break_end = x/2
    
    alt_list = []
    
    for i in range(1,x,1):
        for j in ['A','T','C','G']:
            pre = sequence[0:i]
            lat = sequence[i:x]
            alt = pre + ' ' + j +  ' ' + lat
            # alt = pre  + j  + lat
            if alt in alt_list:
                continue
            else:
                alt_list.append(alt)
            
            pos_pre = int(cutsite) - (x/2-1) + (i - 1)
            pos_lat = pos_pre+1
            
            if strand == '+':
                com_pre = 'Bait_end'
                com_lat = 'Prey_start'
                if (i - 1) <= (x/2-1):
                    condition1 = data[com_pre] == pos_pre
                    condition2 = data[com_lat] > int(cutsite)
                    print("left_end=="+str(pos_pre),"right_end>"+cutsite)
                if (i - 1) > (x/2-1):
                    condition1 = data[com_pre] <= int(cutsite)
                    condition2 = data[com_lat] == pos_pre
                    print("left_end<="+str(pos_pre),"right_end=="+cutsite)
                    
            else:
                com_lat = 'Bait_start'
                com_pre = 'Prey_end'
                if (i - 1) <= (x/2-1):
                    condition1 = data[com_pre] == pos_pre
                    condition2 = data[com_lat] <= int(cutsite)
                    print("left_end=="+str(pos_pre),"right_end<="+cutsite)
                if (i - 1) > (x/2-1):
                    condition1 = data[com_pre] <= int(cutsite)
                    condition2 = data[com_lat] == pos_pre
                    print("left_end<="+cutsite,"right_end=="+str(pos_pre))
                    
            condition3 = data['Insertion'] == j
            
            datb = data[condition1][condition2][condition3]
            num = datb['Qname'].count()
            print(alt,num)
            one_insertion.write(alt+"\t"+\
                                str(num)+"\n")            
    one_insertion.close()
    
def two_insertion(sequence=None,cutsite=None,tab_file=None,strand=None):
    
    data = pd.read_csv(tab_file,sep = '\t',index_col=False,low_memory=False)
    
    two_insertion = open("two_insertion.txt","w")    
    two_insertion.write("Sequence"+"\t"+\
                        "Count"+"\n")
    
    x=len(sequence)
    break_end = x/2
    
    alt_list = []
    
    for i in range(1,x,1):
        for j in ['AA','AT','AC','AG','TA','TT','TC','TG','CA','CT','CC','CG','GA','GT','GC','GG']:
            pre = sequence[0:i]
            lat = sequence[i:x]
            # alt = pre + ' ' + j +  ' ' + lat
            alt = pre  + j  + lat
            if alt in alt_list:
                continue
            else:
                alt_list.append(alt)
            
            pos_pre = int(cutsite) - (x/2-1) + i - 1
            pos_lat = pos_pre+1
    
            if strand == '+':
                com_pre = 'Bait_end'
                com_lat = 'Prey_start'
            else:
                com_lat = 'Bait_start'
                com_pre = 'Prey_end'
        
            condition1 = data[com_pre] == pos_pre
            condition2 = data[com_lat] == pos_lat
            condition3 = data['Insertion'] == j
    
            datb = data[condition1][condition2][condition3]
            num = datb['Qname'].count()
            print(alt,num)
            two_insertion.write(alt+"\t"+\
                                str(num)+"\n")            
    two_insertion.close()
    
def main():
    args = docopt(__doc__,version='Analyze_perfect_insertion 1.0')
    
    kwargs = {'sequence':args['<sequence>'], 'cutsite':args['<cutsite>'], 'tab_file':args['<tab_file>'], 'strand':args['<strand>']}
    print('[PEM-Q-TOOL] sequence: ' + str(kwargs['sequence']))
    print('[PEM-Q-TOOL] cutsite: ' + str(kwargs['cutsite']))
    print('[PEM-Q-TOOL] tab_file: ' + str(kwargs['tab_file']))
    print('[PEM-Q-TOOL] strand: ' + str(kwargs['strand']))
    

    one_insertion(**kwargs)
    # two_insertion(**kwargs)
    
if __name__ == '__main__':
    main()